#!/bin/bash
#
# ---------------------------------
# Some basic setting
# ---------------------------------
    SCRIPT_PATH="$(readlink -f $0)"
    SCRIPT_DIR="$(dirname "$THIS_SCRIPT")"
    # echo "PWD is :$THIS_SCRIPT"

# ---------------------------------
# Some Helper function here
# ---------------------------------
    step_header() {
        echo "-------------------------------------------"
        echo "[Info]: Step ${FUNCNAME[1]}"
        echo 
        assertvars "$@"
        echo "-------------------------------------------"
    }

    usage() {
        echo "USAGE: "
        echo "      --os  |-o)        target os [windows|mac|linux]"
        echo "      --arch|-a)        target arch [x86_64|arm64|risv64]"
        echo "      --root|-r)        target root [\$PEM_HOME|\$PEM_DATA_HOME]"
        echo 
        echo "      -- [module name]) target module to install [fzf|rg|...]"
        echo "EXAMPE:"
        echo "      ./bootstrap --os linux --arch x86_64 --root $PEM_HOME fzf "
    }

    cmd() {
        if  [ "$NODEBUG" = "true" ] ; then
            echo "Runing...:  $@"
            echo 
            time "$@"
            return "$?"
        else 
            echo "Runing...:  $@"
            echo 
            return "$?"
        fi
    }

    checkvars() {
        for x in $@ 
        do
            declare -n p="$x"
            echo "[Info]: Var '$x' is '$p'"
        done
    }

    assertvars() {
        for x in $@ 
        do
            declare -n p="$x"
            echo "[Info]: Var '$x' is '$p'"
            [ -n "$p" ] || {
                echo "[Err]: Var '$x' is empty"
                echo "     : pls check(${FUNCNAME[1]})"
            }
        done
    }

    q-extract ()
    {
        [ -n "$1" ] || return 1
        [ -n "$2" ] || return 2

        if [ -f "$1" ]; then
            case "$1" in
                *.tar.bz2)
                    tar -xvjf "$1" -C "${2}"
                ;;
                *.tar.gz)
                    tar -xvzf "$1" -C "${2}"
                ;;
                *.tar.xz)
                    tar -xvJf "$1" -C "${2}"
                ;;
                *.tar.zst)
                    tar --use-compress-program=unzstd -xvf "$1" -C "${2}"
                ;;
                *.tar)
                    tar -xvf "$1" -C "${2}"
                ;;
                *.tbz2)
                    tar -xvjf "$1" -C "${2}"
                ;;
                *.tgz)
                    tar -xvzf "$1" -C "${2}"
                ;;
                # *.bz2)
                #     bunzip2 "$1"
                # ;;
                # *.rar)
                #     rar x $1
                # ;;
                # *.gz)
                #     gunzip $1
                # ;;
                *.zip)
                    unzip $1 -d "${2}"
                ;;
                # *.Z)
                #     uncompress $1
                # ;;
                # *.7z)
                #     7z x $1
                # ;;
                *)
                    echo "don't know how to extract '$1'..."
                ;;
            esac;
        else
            echo "'$1' is not a valid file!";
        fi
    }
# ---------------------------------
# Step to run
# ---------------------------------
    download_extract() {
        # set -x 
        # [ -n "$tempdir" ]    && 
        # [ -n "$url" ]        && 
        # [ -n "$filename" ]   || {
        #         echo "[Err]: emprty download sheet "
        #         echo "     : pls check"
        #         exit 1
        # }
        # set +x
        #
        step_header tempdir url filename
        touch "$tempdir/.INIT_FLAG"

        cmd wget --directory-prefix="${tempdir}" "${url}"  || {
            echo "[Err]: fail to download"
            rm -rvf "${tempdir:-/UNKNOW}"
            return 1
        }
        if [ "$skip_extract" = true ] ; then 
            echo "Skiping extract due to \$skip_extract = true"
            return 0
        fi
        cmd q-extract "$tempdir/$filename" "$tempdir"
        # echo "[Info]: success install, now clear temp dir" && {
        #     rm -rvf "${tempdir:-/UNKNOW}"
        #     return 0
        # }
        # echo 
    }

    copy_bin() {
        # set -x 
        # [ -n "$tempdir" ]    && 
        # [ -n "$bin_target_dir" ]  &&
        # [ -n "$bin_source_path" ]    &&
        # [ -n "$bin_root" ]     &&
        # [ -n "$bin_target_name" ] &&
        # [ -n "$bin_target_dir" ] || {
        #         echo "[Err]: emprty download sheet "
        #         echo "     : pls check"
        #         exit 1
        # }
        # set +x
        step_header tempdir bin_source_path bin_root \
            bin_target_dir bin_target_name
        set -e

        cmd mkdir -p "$bin_root/$bin_target_dir"
        cmd cp -i "$tempdir/$bin_source_path" "$bin_root/$bin_target_dir/$bin_target_name" || {
            echo "[Err]: fail to cp"
            rm -rvf "${tempdir:-/UNKNOW}"
            return 1
        }
        cmd chmod a+x "$bin_root/$bin_target_dir/$bin_target_name"
        set +e
    }

    clear_temp() {
        # set -x 
        # [ -n "$tempdir" ] || {
        #         echo "[Err]: emprty download sheet "
        #         echo "     : pls check"
        #         exit 1
        # }
        # set +x
        step_header tempdir

        cmd rm -rfv "${tempdir:-/UNKNOW}"
    }



# ---------------------------------
# Actually logic
# ---------------------------------
    parse_arg() {

        # echo "$@"
        local origin_argv="$@"
        local origin_argc="$#"

        local long_arg_list='
        arch:,
        os:,
        root:,
        name:,
        '

        local short_arg_list='
        a:,
        o:,
        r:,
        n:,
        '

        # using local cmdline="$@"
        # -- $cmdline will casue '*' expend
        # use $@ directly will avoid this
        local format_arg=$( getopt \
            -o "$short_arg_list" \
            -l "$long_arg_list" \
            -q \
            -- "$@" )
                local getopt_res=$?
                [ $getopt_res = 0 ] || {
                    error_echo "Fail to run getopt"
                }
                # echo $format_arg
                eval set -- $format_arg
                # echo "$@"

        # return

        CONF_ARCH=
        CONF_OS=
        CONF_ROOT=
        CONF_NAME=
        while true ; do
            case $1 in
                -a|--arch)
                    shift
                    CONF_ARCH="$1"
                    shift ;;
                -o|--os)
                    shift
                    CONF_OS="$1"
                    shift ;;
                -r|--root)
                    shift
                    CONF_ROOT="$1"
                    shift ;;
                -n|--name)
                    shift
                    CONF_NAME="$1"
                    shift ;;
                --)
                    shift
                    CONF_MODULE="$@"
                    # echo "$1"
                    # echo "$2"
                    # echo "NEw"
                    break ;;
                *)
                    error_echo "Unknow case"
                    exit 1 ;;
            esac
        done
        # if '*' in var
        # use "$VAR" to prevent expand
        # echo "$CONF_GLOB"
        [ $origin_argc = 0 ] &&
            usage && exit 0
        check_args "$@"

    }

    check_args() {
        [ -n "$CONF_ROOT" ] && [ -d "$CONF_ROOT" ] || {
            echo "[Err]: rootpath (--root|-r|g:CONF_ROOT) not given"
            echo "     : e.g --root $HOME/.config/pem"
            exit 1
        }

        [ -n "$CONF_OS" ] || {
            echo "[Err]: os (--os|-o|g:CONF_OS) not given"
            echo "     : e.g --os linux"
            exit 1
        }

        [ -n "$CONF_ARCH" ] || {
            echo "[Err]: arch (--arch|-a|g:CONF_ARCH) not given"
            echo "     : e.g --arch x86_64"
            exit 1
        }
        [ -n "$CONF_MODULE" ] || {
            echo "[Err]: module (-- [module name]) not given"
            echo "     : e.g -- rg"
            exit 1
        }
    }


# ---------------------------------
# Main function here
# ---------------------------------

NODEBUG=true
parse_arg "$@"
set -x


for x in $CONF_MODULE
do
    [ -f "${SCRIPT_DIR}/bucket/install-$x.bash" ] && {
        source "${SCRIPT_DIR}/bucket/install-$x.bash"
    }

    echo "=============================================================="
    echo "[Info]: Now install Module '$x'"
    echo "=============================================================="
    install-$x
done
